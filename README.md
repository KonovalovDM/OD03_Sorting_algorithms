# OD03_Sorting_algorithms
 Sorting_algorithms_Алгоритмы сортировки

## Ознакомление с основными алгоритмами сортировки

"""
    Сортируем один и тот же список:

    Заданный список:
    [5, 18, 7, 0, -5, 4, 14, 3, 27, -2, 21, 8, -13, 2, 6, 10, 23, 15, 27, 23]

    Количество элементов в списке:
    20

    Отсортированный список:
    [-13, -5, -2, 0, 2, 3, 4, 5, 6, 7, 8, 10, 14, 15, 18, 21, 23, 23, 27, 27]

##  Сравнение времени выполнения сортировки

###    Пузырьковая сортировка (Bubble Sort);
        19.100 микросекунд

###    Сортировка выбором (Selection Sort);
        10.200 микросекунд

###    Сортировка вставками (Insertion Sort);
        7.600 микросекунд

###    Быстрая сортировка (Quick Sort);
        14.600 микросекунд

###    Сортировка слиянием (Merge Sort).
        22.000 микросекунд


##  Сложность алгоритмов по Big O

###  Пузырьковая сортировка (Bubble Sort)
    Суммарное количество операций:
    T(n)=(n−1)+(n−2)+...+1=n(n−1)/2
    Это даёт сложность O(n^2).

    Итоговая оценка:
    Худший случай: O(n^2)
    Лучший случай: O(n)
    Средний случай: O(n^2)

###  Сортировка выбором (Selection Sort);
    Суммарное количество операций:
    T(n)=(n−1)+(n−2)+...+1=n(n−1)/2
    Это соответствует временной сложности O(n^2).

    Итог:
    Временная сложность: O(n^2) во всех случаях.
    Пространственная сложность: O(1).
    Особенности:
        Несмотря на одинаковую сложность O(n^2) с пузырьковой сортировкой,
        алгоритм Selection Sort выполняет меньше обменов элементов, 
        что может быть преимуществом в некоторых случаях.

###  Сортировка вставками (Insertion Sort);
    Суммарное количество операций:
    T(n)=(n−1)+(n−2)+...+1=n(n−1)/2
    Это соответствует временной сложности O(n^2).

    Итог:
    Временная сложность:
        Худший случай: O(n^2),
        Лучший случай: O(n),
        Средний случай: O(n^2).
    Пространственная сложность: O(1).
    Особенности:
        В лучшем случае O(n) делает алгоритм более эффективным для почти отсортированных массивов.
        Неэффективен для больших массивов в худшем или среднем случаях.

###  Быстрая сортировка (Quick Sort);
    Временная сложность:
    Худший случай:
    T(n)=(n−1)+(n−2)+...+1=n(n−1)/2
    Это соответствует временной сложности O(n^2).
    Средний и Лучший случай:
    O(n log n)

    Итог:
    Временная сложность:
        Лучший случай: O(n log n),
        Средний случай: O(n log n),
        Худший случай: O(n^2).
    Пространственная сложность: O(n) в среднем или O(n+log n) при учете глубины рекурсии.

###  Сортировка слиянием (Merge Sort).
    Итоговая оценка сложности:
    Временная сложность:
        Лучший случай:  O(n log n),
        Средний случай: O(n log n),
        Худший случай:  O(n log n).
    Пространственная сложность: O(n) из-за использования дополнительных массивов.

    Преимущества Merge Sort:
    Стабильность: Сортировка слиянием сохраняет порядок одинаковых элементов.
    Предсказуемость: Сложность всегда O(n log n), независимо от входных данных
    (в отличие от Quick Sort).

    Недостатки:
    Память: Требуется дополнительная память для хранения временных массивов.
"""

## ОБЩИЕ ВЫВОДЫ
Наименьшее время выполнения, которое мы наблюдаем (7,6 микросекунды для Сортировки вставками),<br>
связано с особенностями измерений на небольших входных данных и конкретной реализации,<br>
а не с реальной эффективностью алгоритма.<br>
Давайте раcсмотрим, почему так:

---

### 1. **Размер входного списка**
Cписок содержит всего 20 элементов. На таких малых данных накладные расходы сложных алгоритмов (например, рекурсия в Merge Sort или генерация списков в Quick Sort) могут сделать их медленнее, чем более простые подходы.

- **Insertion Sort** эффективен на маленьких массивах, так как в среднем перемещает элементы быстро, особенно если массив частично отсортирован.

---

### 2. **Характеристики входных данных**
- **Сортировка вставками** работает особенно быстро на уже частично отсортированных данных, так как внешний цикл почти не требует перемещений.
- В списке выше нет больших отклонений, что делает сортировку вставками эффективной.

---

### 3. **Влияние измерений времени**
- Для очень коротких задач (порядка микросекунд) система измерения времени может давать шумовые значения из-за задержек:
  - Системных вызовов.
  - Накладных расходов функции `perf_counter`.

Для объективного сравнения алгоритмов необходимо тестировать их на больших массивах<br>
(например, \(n = 10^4\) или \(10^6\)) и проводить многократные замеры.

---

### 4. **Теоретическая эффективность**
- **Insertion Sort:**
  - Временная сложность: \(O(n^2)\) в худшем случае.
  - Для больших массивов его производительность резко падает.
- **Merge Sort:**
  - Временная сложность: \(O(n log n)\), что значительно быстрее на больших данных.
  - Лидирует на масштабируемости.

---

### 5. **Вывод**
На малых массивах \(n leq 20\), такие простые алгоритмы, как **Insertion Sort**,<br>
действительно могут показывать лучшее время выполнения.<br>
Но с увеличением размера массива он проиграет более эффективным алгоритмам,<br>
таким как Merge Sort или Quick Sort, из-за своей квадратичной временной сложности \(O(n^2)\).